from handlers.handler import HANDLERS
from handlers.temporal_anomaly import TemporalAnomalyDetectionHandler

from models.tcn.MSTCN import MultiStageModel
import numpy as np


@HANDLERS.register_module(name="mstcn")
class MSTCNHandler(TemporalAnomalyDetectionHandler):
    def __init__(self, cfg):
        TemporalAnomalyDetectionHandler.__init__(self, cfg)

    def get_model(self, model_cfg):
        model = MultiStageModel(num_stages=model_cfg.num_stages, num_layers=model_cfg.num_layers,
                                num_f_maps=model_cfg.hidden_win_size,
                                feat_dim=model_cfg.feature_size, ssRepeat=model_cfg.first_stage_repeat)
        return model

    def model_forward(self, data, evaluate=False, **kwargs):
        # TODO: report can be generated by model handler class (?)
        data = self.move_2_gpu(data)

        loss = 0
        report = dict()
        stage_clip_dicts = None
        # clip_dicts = None
        loss_dict = {"{}_loss".format(loss_type): [] for loss_type, loss_cfg in self.losses.items()}

        outputs = self.model(data["input"], data["masks"])
        for stage_index, stage_output in enumerate(outputs):
            stage_output = stage_output.mean(1)
            stage_loss, loss_outputs = self.calculate_loss(stage_output, data['anomalies'])
            for loss_type, loss_value in loss_outputs.items():
                report["loss/layer-{}-{}".format(loss_type, stage_index)] = loss_value.item()
                loss_dict["{}_loss".format(loss_type)].append(loss_value.item())
            loss += stage_loss

        for loss_type, loss_cfg in self.losses.items():
            loss_dict['{}_loss'.format(loss_type)] = np.array(loss_dict['{}_loss'.format(loss_type)]).mean()

        loss_dict['total_loss'] = loss.item()
        report['total_loss'] = loss.item()

        if evaluate:
            stage_clip_dicts = []
            for stage_index in range(len(outputs)):
                c_data = self.clip_outputs(outputs[stage_index], data['anomalies'], data['clip_names'])
                clip_dicts = self.append_overlapped_clips(c_data)
                stage_clip_dicts.append(clip_dicts)

            # c_data = self.clip_outputs(outputs[-1], data['anomalies'], data['clip_names'])
            # clip_dicts = self.append_overlapped_clips(c_data)

        return loss, report, stage_clip_dicts, loss_dict
